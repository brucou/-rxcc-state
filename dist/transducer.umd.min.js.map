{"version":3,"file":"transducer.umd.min.js","sources":["../src/properties.js","../node_modules/json-patch-es6/lib/deep-equal.js","../node_modules/json-patch-es6/lib/helpers.js","../node_modules/json-patch-es6/lib/core.js","../src/helpers.js","../src/synchronous_fsm.js","../node_modules/fp-rosetree/index.js","../src/converter.js"],"sourcesContent":["export const CONTRACT_MODEL_UPDATE_FN_RETURN_VALUE =\r\n  `Model update function must return valid update operations!`;\r\nexport const SEP = '.';\r\nexport const TRANSITION_SYMBOL = `-->`;\r\nexport const TRANSITION_LABEL_START_SYMBOL = `:`;\r\nexport const HISTORY_STATE_NAME = \"H\";\r\nexport const HISTORY_PREFIX = 'history.'\r\n// CONSTANTS\r\nexport const INITIAL_STATE_NAME = 'nok';\r\nexport const INIT_EVENT = 'init';\r\nexport const AUTO_EVENT = 'auto';\r\nexport const STATE_PROTOTYPE_NAME = 'State'; // !!must be the function name for the constructor State,\r\n// i.e. State\r\nexport const NO_MODEL_UPDATE = [];\r\n// NOTE : this really cannot be anything else than a falsy value, beware\r\nexport const NO_OUTPUT = null;\r\nexport const default_action_result = {\r\n  model_update: NO_MODEL_UPDATE,\r\n  output: NO_OUTPUT\r\n};\r\n\r\n","var pSlice = Array.prototype.slice;\r\nvar objectKeys = Object.keys;\r\nfunction isArguments(object) {\r\n    return Object.prototype.toString.call(object) == '[object Arguments]';\r\n}\r\n;\r\nfunction isUndefinedOrNull(value) {\r\n    return value === null || value === undefined;\r\n}\r\nfunction isBuffer(x) {\r\n    if (!x || typeof x !== 'object' || typeof x.length !== 'number')\r\n        return false;\r\n    if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {\r\n        return false;\r\n    }\r\n    if (x.length > 0 && typeof x[0] !== 'number')\r\n        return false;\r\n    return true;\r\n}\r\nfunction objEquiv(a, b, opts) {\r\n    var i, key;\r\n    if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\r\n        return false;\r\n    // an identical 'prototype' property.\r\n    if (a.prototype !== b.prototype)\r\n        return false;\r\n    //~~~I've managed to break Object.keys through screwy arguments passing.\r\n    //   Converting to array solves the problem.\r\n    if (isArguments(a)) {\r\n        if (!isArguments(b)) {\r\n            return false;\r\n        }\r\n        a = pSlice.call(a);\r\n        b = pSlice.call(b);\r\n        return deepEqual(a, b, opts);\r\n    }\r\n    if (isBuffer(a)) {\r\n        if (!isBuffer(b)) {\r\n            return false;\r\n        }\r\n        if (a.length !== b.length)\r\n            return false;\r\n        for (i = 0; i < a.length; i++) {\r\n            if (a[i] !== b[i])\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n    try {\r\n        var ka = objectKeys(a), kb = objectKeys(b);\r\n    }\r\n    catch (e) {\r\n        return false;\r\n    }\r\n    // having the same number of owned properties (keys incorporates\r\n    // hasOwnProperty)\r\n    if (ka.length != kb.length)\r\n        return false;\r\n    //the same set of keys (although not necessarily the same order),\r\n    ka.sort();\r\n    kb.sort();\r\n    //~~~cheap key test\r\n    for (i = ka.length - 1; i >= 0; i--) {\r\n        if (ka[i] != kb[i])\r\n            return false;\r\n    }\r\n    //equivalent values for every corresponding key, and\r\n    //~~~possibly expensive deep test\r\n    for (i = ka.length - 1; i >= 0; i--) {\r\n        key = ka[i];\r\n        if (!deepEqual(a[key], b[key], opts))\r\n            return false;\r\n    }\r\n    return typeof a === typeof b;\r\n}\r\nexport function deepEqual(actual, expected, opts) {\r\n    if (!opts)\r\n        opts = {};\r\n    // 7.1. All identical values are equivalent, as determined by ===.\r\n    if (actual === expected) {\r\n        return true;\r\n    }\r\n    else if (actual instanceof Date && expected instanceof Date) {\r\n        return actual.getTime() === expected.getTime();\r\n    }\r\n    else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {\r\n        return opts.strict ? actual === expected : actual == expected;\r\n    }\r\n    else {\r\n        return objEquiv(actual, expected, opts);\r\n    }\r\n}\r\n;\r\n","var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\n/*!\r\n * https://github.com/Starcounter-Jack/JSON-Patch\r\n * (c) 2017 Joachim Wester\r\n * MIT license\r\n */\r\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\r\nexport function hasOwnProperty(obj, key) {\r\n    return _hasOwnProperty.call(obj, key);\r\n}\r\nexport function _objectKeys(obj) {\r\n    if (Array.isArray(obj)) {\r\n        var keys = new Array(obj.length);\r\n        for (var k = 0; k < keys.length; k++) {\r\n            keys[k] = \"\" + k;\r\n        }\r\n        return keys;\r\n    }\r\n    if (Object.keys) {\r\n        return Object.keys(obj);\r\n    }\r\n    var keys = [];\r\n    for (var i in obj) {\r\n        if (hasOwnProperty(obj, i)) {\r\n            keys.push(i);\r\n        }\r\n    }\r\n    return keys;\r\n}\r\n;\r\n/**\r\n* Deeply clone the object.\r\n* https://jsperf.com/deep-copy-vs-json-stringify-json-parse/25 (recursiveDeepCopy)\r\n* @param  {any} obj value to clone\r\n* @return {any} cloned obj\r\n*/\r\nexport function _deepClone(obj) {\r\n    switch (typeof obj) {\r\n        case \"object\":\r\n            return JSON.parse(JSON.stringify(obj)); //Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5\r\n        case \"undefined\":\r\n            return null; //this is how JSON.stringify behaves for array items\r\n        default:\r\n            return obj; //no need to clone primitives\r\n    }\r\n}\r\n//3x faster than cached /^\\d+$/.test(str)\r\nexport function isInteger(str) {\r\n    var i = 0;\r\n    var len = str.length;\r\n    var charCode;\r\n    while (i < len) {\r\n        charCode = str.charCodeAt(i);\r\n        if (charCode >= 48 && charCode <= 57) {\r\n            i++;\r\n            continue;\r\n        }\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n/**\r\n* Escapes a json pointer path\r\n* @param path The raw pointer\r\n* @return the Escaped path\r\n*/\r\nexport function escapePathComponent(path) {\r\n    if (path.indexOf('/') === -1 && path.indexOf('~') === -1)\r\n        return path;\r\n    return path.replace(/~/g, '~0').replace(/\\//g, '~1');\r\n}\r\n/**\r\n * Unescapes a json pointer path\r\n * @param path The escaped pointer\r\n * @return The unescaped path\r\n */\r\nexport function unescapePathComponent(path) {\r\n    return path.replace(/~1/g, '/').replace(/~0/g, '~');\r\n}\r\nexport function _getPathRecursive(root, obj) {\r\n    var found;\r\n    for (var key in root) {\r\n        if (hasOwnProperty(root, key)) {\r\n            if (root[key] === obj) {\r\n                return escapePathComponent(key) + '/';\r\n            }\r\n            else if (typeof root[key] === 'object') {\r\n                found = _getPathRecursive(root[key], obj);\r\n                if (found != '') {\r\n                    return escapePathComponent(key) + '/' + found;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return '';\r\n}\r\nexport function getPath(root, obj) {\r\n    if (root === obj) {\r\n        return '/';\r\n    }\r\n    var path = _getPathRecursive(root, obj);\r\n    if (path === '') {\r\n        throw new Error(\"Object not found in root\");\r\n    }\r\n    return '/' + path;\r\n}\r\n/**\r\n* Recursively checks whether an object has any undefined values inside.\r\n*/\r\nexport function hasUndefined(obj) {\r\n    if (obj === undefined) {\r\n        return true;\r\n    }\r\n    if (obj) {\r\n        if (Array.isArray(obj)) {\r\n            for (var i = 0, len = obj.length; i < len; i++) {\r\n                if (hasUndefined(obj[i])) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        else if (typeof obj === \"object\") {\r\n            var objKeys = _objectKeys(obj);\r\n            var objKeysLength = objKeys.length;\r\n            for (var i = 0; i < objKeysLength; i++) {\r\n                if (hasUndefined(obj[objKeys[i]])) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\nexport var PatchError = (function (_super) {\r\n    __extends(PatchError, _super);\r\n    function PatchError(message, name, index, operation, tree) {\r\n        _super.call(this, message);\r\n        this.message = message;\r\n        this.name = name;\r\n        this.index = index;\r\n        this.operation = operation;\r\n        this.tree = tree;\r\n    }\r\n    return PatchError;\r\n}(Error));\r\n","import { deepEqual as _equals } from './deep-equal';\r\nvar equalsOptions = { strict: true };\r\n//const _equals = require('deep-equal');\r\nvar areEquals = function (a, b) {\r\n    return _equals(a, b, equalsOptions);\r\n};\r\nimport { PatchError, _deepClone, isInteger, unescapePathComponent, hasUndefined } from './helpers';\r\nexport var JsonPatchError = PatchError;\r\nexport var deepClone = _deepClone;\r\n/* We use a Javascript hash to store each\r\n function. Each hash entry (property) uses\r\n the operation identifiers specified in rfc6902.\r\n In this way, we can map each patch operation\r\n to its dedicated function in efficient way.\r\n */\r\n/* The operations applicable to an object */\r\nvar objOps = {\r\n    add: function (obj, key, document) {\r\n        obj[key] = this.value;\r\n        return { newDocument: document };\r\n    },\r\n    remove: function (obj, key, document) {\r\n        var removed = obj[key];\r\n        delete obj[key];\r\n        return { newDocument: document, removed: removed };\r\n    },\r\n    replace: function (obj, key, document) {\r\n        var removed = obj[key];\r\n        obj[key] = this.value;\r\n        return { newDocument: document, removed: removed };\r\n    },\r\n    move: function (obj, key, document) {\r\n        /* in case move target overwrites an existing value,\r\n        return the removed value, this can be taxing performance-wise,\r\n        and is potentially unneeded */\r\n        var removed = getValueByPointer(document, this.path);\r\n        if (removed) {\r\n            removed = _deepClone(removed);\r\n        }\r\n        var originalValue = applyOperation(document, { op: \"remove\", path: this.from }).removed;\r\n        applyOperation(document, { op: \"add\", path: this.path, value: originalValue });\r\n        return { newDocument: document, removed: removed };\r\n    },\r\n    copy: function (obj, key, document) {\r\n        var valueToCopy = getValueByPointer(document, this.from);\r\n        // enforce copy by value so further operations don't affect source (see issue #177)\r\n        applyOperation(document, { op: \"add\", path: this.path, value: _deepClone(valueToCopy) });\r\n        return { newDocument: document };\r\n    },\r\n    test: function (obj, key, document) {\r\n        return { newDocument: document, test: areEquals(obj[key], this.value) };\r\n    },\r\n    _get: function (obj, key, document) {\r\n        this.value = obj[key];\r\n        return { newDocument: document };\r\n    }\r\n};\r\n/* The operations applicable to an array. Many are the same as for the object */\r\nvar arrOps = {\r\n    add: function (arr, i, document) {\r\n        if (isInteger(i)) {\r\n            arr.splice(i, 0, this.value);\r\n        }\r\n        else {\r\n            arr[i] = this.value;\r\n        }\r\n        // this may be needed when using '-' in an array\r\n        return { newDocument: document, index: i };\r\n    },\r\n    remove: function (arr, i, document) {\r\n        var removedList = arr.splice(i, 1);\r\n        return { newDocument: document, removed: removedList[0] };\r\n    },\r\n    replace: function (arr, i, document) {\r\n        var removed = arr[i];\r\n        arr[i] = this.value;\r\n        return { newDocument: document, removed: removed };\r\n    },\r\n    move: objOps.move,\r\n    copy: objOps.copy,\r\n    test: objOps.test,\r\n    _get: objOps._get\r\n};\r\n/**\r\n * Retrieves a value from a JSON document by a JSON pointer.\r\n * Returns the value.\r\n *\r\n * @param document The document to get the value from\r\n * @param pointer an escaped JSON pointer\r\n * @return The retrieved value\r\n */\r\nexport function getValueByPointer(document, pointer) {\r\n    if (pointer == '') {\r\n        return document;\r\n    }\r\n    var getOriginalDestination = { op: \"_get\", path: pointer };\r\n    applyOperation(document, getOriginalDestination);\r\n    return getOriginalDestination.value;\r\n}\r\n/**\r\n * Apply a single JSON Patch Operation on a JSON document.\r\n * Returns the {newDocument, result} of the operation.\r\n * It modifies the `document` and `operation` objects - it gets the values by reference.\r\n * If you would like to avoid touching your values, clone them:\r\n * `jsonpatch.applyOperation(document, jsonpatch._deepClone(operation))`.\r\n *\r\n * @param document The document to patch\r\n * @param operation The operation to apply\r\n * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.\r\n * @param mutateDocument Whether to mutate the original document or clone it before applying\r\n * @return `{newDocument, result}` after the operation\r\n */\r\nexport function applyOperation(document, operation, validateOperation, mutateDocument) {\r\n    if (validateOperation === void 0) { validateOperation = false; }\r\n    if (mutateDocument === void 0) { mutateDocument = true; }\r\n    if (validateOperation) {\r\n        if (typeof validateOperation == 'function') {\r\n            validateOperation(operation, 0, document, operation.path);\r\n        }\r\n        else {\r\n            validator(operation, 0);\r\n        }\r\n    }\r\n    /* ROOT OPERATIONS */\r\n    if (operation.path === \"\") {\r\n        var returnValue = { newDocument: document };\r\n        if (operation.op === 'add') {\r\n            returnValue.newDocument = operation.value;\r\n            return returnValue;\r\n        }\r\n        else if (operation.op === 'replace') {\r\n            returnValue.newDocument = operation.value;\r\n            returnValue.removed = document; //document we removed\r\n            return returnValue;\r\n        }\r\n        else if (operation.op === 'move' || operation.op === 'copy') {\r\n            returnValue.newDocument = getValueByPointer(document, operation.from); // get the value by json-pointer in `from` field\r\n            if (operation.op === 'move') {\r\n                returnValue.removed = document;\r\n            }\r\n            return returnValue;\r\n        }\r\n        else if (operation.op === 'test') {\r\n            returnValue.test = areEquals(document, operation.value);\r\n            if (returnValue.test === false) {\r\n                throw new JsonPatchError(\"Test operation failed\", 'TEST_OPERATION_FAILED', 0, operation, document);\r\n            }\r\n            returnValue.newDocument = document;\r\n            return returnValue;\r\n        }\r\n        else if (operation.op === 'remove') {\r\n            returnValue.removed = document;\r\n            returnValue.newDocument = null;\r\n            return returnValue;\r\n        }\r\n        else if (operation.op === '_get') {\r\n            operation.value = document;\r\n            return returnValue;\r\n        }\r\n        else {\r\n            if (validateOperation) {\r\n                throw new JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', 0, operation, document);\r\n            }\r\n            else {\r\n                return returnValue;\r\n            }\r\n        }\r\n    } /* END ROOT OPERATIONS */\r\n    else {\r\n        if (!mutateDocument) {\r\n            document = _deepClone(document);\r\n        }\r\n        var path = operation.path || \"\";\r\n        var keys = path.split('/');\r\n        var obj = document;\r\n        var t = 1; //skip empty element - http://jsperf.com/to-shift-or-not-to-shift\r\n        var len = keys.length;\r\n        var existingPathFragment = undefined;\r\n        var key = void 0;\r\n        var validateFunction = void 0;\r\n        if (typeof validateOperation == 'function') {\r\n            validateFunction = validateOperation;\r\n        }\r\n        else {\r\n            validateFunction = validator;\r\n        }\r\n        while (true) {\r\n            key = keys[t];\r\n            if (validateOperation) {\r\n                if (existingPathFragment === undefined) {\r\n                    if (obj[key] === undefined) {\r\n                        existingPathFragment = keys.slice(0, t).join('/');\r\n                    }\r\n                    else if (t == len - 1) {\r\n                        existingPathFragment = operation.path;\r\n                    }\r\n                    if (existingPathFragment !== undefined) {\r\n                        validateFunction(operation, 0, document, existingPathFragment);\r\n                    }\r\n                }\r\n            }\r\n            t++;\r\n            if (Array.isArray(obj)) {\r\n                if (key === '-') {\r\n                    key = obj.length;\r\n                }\r\n                else {\r\n                    if (validateOperation && !isInteger(key)) {\r\n                        throw new JsonPatchError(\"Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index\", \"OPERATION_PATH_ILLEGAL_ARRAY_INDEX\", 0, operation.path, operation);\r\n                    } // only parse key when it's an integer for `arr.prop` to work\r\n                    else if (isInteger(key)) {\r\n                        key = ~~key;\r\n                    }\r\n                }\r\n                if (t >= len) {\r\n                    if (validateOperation && operation.op === \"add\" && key > obj.length) {\r\n                        throw new JsonPatchError(\"The specified index MUST NOT be greater than the number of elements in the array\", \"OPERATION_VALUE_OUT_OF_BOUNDS\", 0, operation.path, operation);\r\n                    }\r\n                    var returnValue = arrOps[operation.op].call(operation, obj, key, document); // Apply patch\r\n                    if (returnValue.test === false) {\r\n                        throw new JsonPatchError(\"Test operation failed\", 'TEST_OPERATION_FAILED', 0, operation, document);\r\n                    }\r\n                    return returnValue;\r\n                }\r\n            }\r\n            else {\r\n                if (key && key.indexOf('~') != -1) {\r\n                    key = unescapePathComponent(key);\r\n                }\r\n                if (t >= len) {\r\n                    var returnValue = objOps[operation.op].call(operation, obj, key, document); // Apply patch\r\n                    if (returnValue.test === false) {\r\n                        throw new JsonPatchError(\"Test operation failed\", 'TEST_OPERATION_FAILED', 0, operation, document);\r\n                    }\r\n                    return returnValue;\r\n                }\r\n            }\r\n            obj = obj[key];\r\n        }\r\n    }\r\n}\r\n/**\r\n * Apply a full JSON Patch array on a JSON document.\r\n * Returns the {newDocument, result} of the patch.\r\n * It modifies the `document` object and `patch` - it gets the values by reference.\r\n * If you would like to avoid touching your values, clone them:\r\n * `jsonpatch.applyPatch(document, jsonpatch._deepClone(patch))`.\r\n *\r\n * @param document The document to patch\r\n * @param patch The patch to apply\r\n * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.\r\n * @param mutateDocument Whether to mutate the original document or clone it before applying\r\n * @return An array of `{newDocument, result}` after the patch\r\n */\r\nexport function applyPatch(document, patch, validateOperation, mutateDocument) {\r\n    if (mutateDocument === void 0) { mutateDocument = true; }\r\n    if (validateOperation) {\r\n        if (!Array.isArray(patch)) {\r\n            throw new JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');\r\n        }\r\n    }\r\n    if (!mutateDocument) {\r\n        document = _deepClone(document);\r\n    }\r\n    var results = new Array(patch.length);\r\n    for (var i = 0, length_1 = patch.length; i < length_1; i++) {\r\n        results[i] = applyOperation(document, patch[i], validateOperation);\r\n        document = results[i].newDocument; // in case root was replaced\r\n    }\r\n    results.newDocument = document;\r\n    return results;\r\n}\r\n/**\r\n * Apply a single JSON Patch Operation on a JSON document.\r\n * Returns the updated document.\r\n * Suitable as a reducer.\r\n *\r\n * @param document The document to patch\r\n * @param operation The operation to apply\r\n * @return The updated document\r\n */\r\nexport function applyReducer(document, operation) {\r\n    var operationResult = applyOperation(document, operation);\r\n    if (operationResult.test === false) {\r\n        throw new JsonPatchError(\"Test operation failed\", 'TEST_OPERATION_FAILED', 0, operation, document);\r\n    }\r\n    return operationResult.newDocument;\r\n}\r\n/**\r\n * Validates a single operation. Called from `jsonpatch.validate`. Throws `JsonPatchError` in case of an error.\r\n * @param {object} operation - operation object (patch)\r\n * @param {number} index - index of operation in the sequence\r\n * @param {object} [document] - object where the operation is supposed to be applied\r\n * @param {string} [existingPathFragment] - comes along with `document`\r\n */\r\nexport function validator(operation, index, document, existingPathFragment) {\r\n    if (typeof operation !== 'object' || operation === null || Array.isArray(operation)) {\r\n        throw new JsonPatchError('Operation is not an object', 'OPERATION_NOT_AN_OBJECT', index, operation, document);\r\n    }\r\n    else if (!objOps[operation.op]) {\r\n        throw new JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', index, operation, document);\r\n    }\r\n    else if (typeof operation.path !== 'string') {\r\n        throw new JsonPatchError('Operation `path` property is not a string', 'OPERATION_PATH_INVALID', index, operation, document);\r\n    }\r\n    else if (operation.path.indexOf('/') !== 0 && operation.path.length > 0) {\r\n        // paths that aren't empty string should start with \"/\"\r\n        throw new JsonPatchError('Operation `path` property must start with \"/\"', 'OPERATION_PATH_INVALID', index, operation, document);\r\n    }\r\n    else if ((operation.op === 'move' || operation.op === 'copy') && typeof operation.from !== 'string') {\r\n        throw new JsonPatchError('Operation `from` property is not present (applicable in `move` and `copy` operations)', 'OPERATION_FROM_REQUIRED', index, operation, document);\r\n    }\r\n    else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && operation.value === undefined) {\r\n        throw new JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_REQUIRED', index, operation, document);\r\n    }\r\n    else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && hasUndefined(operation.value)) {\r\n        throw new JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED', index, operation, document);\r\n    }\r\n    else if (document) {\r\n        if (operation.op == \"add\") {\r\n            var pathLen = operation.path.split(\"/\").length;\r\n            var existingPathLen = existingPathFragment.split(\"/\").length;\r\n            if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {\r\n                throw new JsonPatchError('Cannot perform an `add` operation at the desired path', 'OPERATION_PATH_CANNOT_ADD', index, operation, document);\r\n            }\r\n        }\r\n        else if (operation.op === 'replace' || operation.op === 'remove' || operation.op === '_get') {\r\n            if (operation.path !== existingPathFragment) {\r\n                throw new JsonPatchError('Cannot perform the operation at a path that does not exist', 'OPERATION_PATH_UNRESOLVABLE', index, operation, document);\r\n            }\r\n        }\r\n        else if (operation.op === 'move' || operation.op === 'copy') {\r\n            var existingValue = { op: \"_get\", path: operation.from, value: undefined };\r\n            var error = validate([existingValue], document);\r\n            if (error && error.name === 'OPERATION_PATH_UNRESOLVABLE') {\r\n                throw new JsonPatchError('Cannot perform the operation from a path that does not exist', 'OPERATION_FROM_UNRESOLVABLE', index, operation, document);\r\n            }\r\n        }\r\n    }\r\n}\r\n/**\r\n * Validates a sequence of operations. If `document` parameter is provided, the sequence is additionally validated against the object document.\r\n * If error is encountered, returns a JsonPatchError object\r\n * @param sequence\r\n * @param document\r\n * @returns {JsonPatchError|undefined}\r\n */\r\nexport function validate(sequence, document, externalValidator) {\r\n    try {\r\n        if (!Array.isArray(sequence)) {\r\n            throw new JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');\r\n        }\r\n        if (document) {\r\n            //clone document and sequence so that we can safely try applying operations\r\n            applyPatch(_deepClone(document), _deepClone(sequence), externalValidator || true);\r\n        }\r\n        else {\r\n            externalValidator = externalValidator || validator;\r\n            for (var i = 0; i < sequence.length; i++) {\r\n                externalValidator(sequence[i], i, document, undefined);\r\n            }\r\n        }\r\n    }\r\n    catch (e) {\r\n        if (e instanceof JsonPatchError) {\r\n            return e;\r\n        }\r\n        else {\r\n            throw e;\r\n        }\r\n    }\r\n}\r\n","// Ramda fns\r\nimport { CONTRACT_MODEL_UPDATE_FN_RETURN_VALUE, HISTORY_PREFIX, HISTORY_STATE_NAME, INIT_EVENT } from \"./properties\"\r\n// import { applyPatch } from \"./fast-json-patch/duplex\"\r\nimport { applyPatch } from \"json-patch-es6\"\r\n\r\n/**\r\n * Returns the name of the function as taken from its source definition.\r\n * For instance, function do_something(){} -> \"do_something\"\r\n * @param fn {Function}\r\n * @returns {String}\r\n */\r\nexport function get_fn_name(fn) {\r\n  const tokens =\r\n    /^[\\s\\r\\n]*function[\\s\\r\\n]*([^\\(\\s\\r\\n]*?)[\\s\\r\\n]*\\([^\\)\\s\\r\\n]*\\)[\\s\\r\\n]*\\{((?:[^}]*\\}?)+)\\}\\s*$/\r\n      .exec(fn.toString());\r\n  return tokens[1];\r\n}\r\n\r\nexport function wrap(str) { return ['-', str, '-'].join(\"\"); }\r\n\r\nexport function times(fn, n) {\r\n  return Array.apply(null, { length: n }).map(Number.call, Number).map(fn)\r\n}\r\n\r\n/**\r\n *\r\n * @param {FSM_Model} model\r\n * @param {JSON_Patch_Operation[]} modelUpdateOperations\r\n * @returns {FSM_Model}\r\n */\r\nexport function applyUpdateOperations(/*OUT*/model, modelUpdateOperations) {\r\n  assertContract(isArrayUpdateOperations, [modelUpdateOperations],\r\n    `applyUpdateOperations : ${CONTRACT_MODEL_UPDATE_FN_RETURN_VALUE}`);\r\n\r\n  return applyPatch(model, modelUpdateOperations, true, false).newDocument;\r\n}\r\n\r\nexport function always(x) {return x}\r\n\r\nexport function keys(obj) {return Object.keys(obj)}\r\n\r\n// Contracts\r\nexport function assertContract(contractFn, contractArgs, errorMessage) {\r\n  const boolOrError = contractFn.apply(null, contractArgs)\r\n  const isPredicateSatisfied = isBoolean(boolOrError) && boolOrError;\r\n\r\n  if (!isPredicateSatisfied) {\r\n    throw `assertContract: fails contract ${contractFn.name}\\n${errorMessage}\\n ${boolOrError}`\r\n  }\r\n  return true\r\n}\r\n\r\nexport function isBoolean(obj) {return typeof(obj) === 'boolean'}\r\n\r\nexport function isUpdateOperation(obj) {\r\n  return (typeof(obj) === 'object' && Object.keys(obj).length === 0) ||\r\n    (\r\n      ['add', 'replace', 'move', 'test', 'remove', 'copy'].some(op => obj.op === op) &&\r\n      typeof(obj.path) === 'string'\r\n    )\r\n}\r\n\r\nexport function isEmptyArray(obj) {return Array.isArray(obj) && obj.length === 0}\r\n\r\nexport function isArrayOf(predicate) {return obj => Array.isArray(obj) && obj.every(predicate)}\r\n\r\nexport function isArrayUpdateOperations(obj) {\r\n  return isEmptyArray(obj) || isArrayOf(isUpdateOperation)(obj)\r\n}\r\n\r\nexport function is_history_transition(transition) {\r\n  return transition.to.startsWith(HISTORY_PREFIX)\r\n}\r\n\r\nexport function is_entry_transition(transition) {\r\n  return transition.event === INIT_EVENT\r\n}\r\n\r\nexport function is_from_control_state(controlState) {\r\n  return function (transition) {\r\n    return transition.from === controlState\r\n  }\r\n}\r\n\r\nexport function is_to_history_control_state_of(controlState) {\r\n  return function (transition) {\r\n    return is_history_control_state_of(controlState, transition.to)\r\n  }\r\n}\r\n\r\nexport function is_history_control_state_of(controlState, state) {\r\n  return state.substring(HISTORY_PREFIX.length) === controlState\r\n}\r\n\r\nexport function format_transition_label(_event, predicate, action) {\r\n  const event = _event || '';\r\n  return predicate && action\r\n    ? `${event} [${predicate.name}] / ${action.name}`\r\n    : predicate\r\n      ? `${event} [${predicate.name}]}`\r\n      : action\r\n        ? `${event} / ${action.name}`\r\n        : `${event}`\r\n}\r\n\r\nexport function format_history_transition_state_name({ from, to }) {\r\n  return `${from}.${to.substring(HISTORY_PREFIX.length)}.${HISTORY_STATE_NAME}`\r\n}\r\n\r\nexport function get_all_transitions(transition) {\r\n  const { from, event, guards } = transition;\r\n\r\n  return guards\r\n    ? guards.map(({ predicate, to, action }) => ({ from, event, predicate, to, action }))\r\n    : [transition];\r\n}\r\n\r\n/**\r\n * 'this_name' => 'this name'\r\n * @param {String} str\r\n * @returns {String}\r\n */\r\nexport function displayName(str) {\r\n  return str.replace(/_/g, ' ')\r\n}\r\n\r\n","// DOC\r\n// CONTRACT : no transition from the history state (history state is only a target state)\r\n// CONTRACT : init events only acceptable in nesting state (aka grouping state)\r\n// NOTE : enforced via in_auto_state only true for grouping state\r\n// CONTRACT : Automatic actions with no events and only conditions are not allowed in nesting state\r\n// (aka grouping state)\r\n// NOTE : That would lead to non-determinism if A < B < C and both A and B\r\n// have such automatic actions CONTRACT : There MUST be an action in each transition\r\n// NOTE : Dead states: - Possible if automatic actions (no events) with conditions always true.\r\n// If there is not another condition which at some point is set to false, we have an infinite\r\n// loop (a very real one which could monopolize the CPU if all actions are synchronous) - To\r\n// break out of it, maybe put a guard that if we remain in the same state for X steps,\r\n// transition automatically (to error or else)\r\n\r\n// TODO : add a null event notion. If a null input is received return a null output, taht means no event\r\n// TODO : in streaming, ignore automatically null events. We don't have a choice but to return null output in the\r\n// normal autoamta. However null could be a valid return, so using a NULL_OUTPUT variable or SYMBOL??!!  We\r\n// basically simulate a Maybe Input -> Maybe Output\r\n// TODO : as a isActualOutput function to discriminate out the Maybe\r\n\r\nimport {\r\n  AUTO_EVENT, default_action_result, INIT_EVENT, INITIAL_STATE_NAME, NO_OUTPUT, STATE_PROTOTYPE_NAME\r\n} from \"./properties\"\r\nimport { applyUpdateOperations, get_fn_name, keys, wrap } from './helpers'\r\n\r\n/**\r\n * Takes a list of identifiers (strings), adds init to it, and returns a hash whose properties are\r\n * the uppercased identifiers For instance :\r\n * ('edit', 'delete') -> {EDIT: 'EDIT', DELETE : 'DELETE', INIT : 'INIT'}\r\n * If there is an init in the list of identifiers, it is overwritten\r\n * RESTRICTION : avoid having init as an identifier\r\n * @param array_identifiers {Array | arguments}\r\n * @returns {Object<String,String>}\r\n */\r\nfunction build_event_enum(array_identifiers) {\r\n  array_identifiers = array_identifiers.reduce ? array_identifiers : Array.prototype.slice.call(arguments);\r\n  // NOTE : That will overwrite any other event called init...\r\n  array_identifiers.push(INIT_EVENT);\r\n  return array_identifiers.reduce(function (acc, identifier) {\r\n    acc[identifier] = identifier;\r\n    return acc;\r\n  }, {})\r\n}\r\n\r\n/**\r\n * Processes the hierarchically nested states and returns miscellaneous objects derived from it:\r\n * `is_group_state` : {Object<String,Boolean>} Hash whose properties (state names) are matched with\r\n * whether that state is a nested state\r\n * `hash_states` : Hierarchically nested object whose properties are the nested states.\r\n * - Nested states inherit (prototypal inheritance) from the containing state.\r\n * - Holds a `history` property which holds a `last_seen_state` property which holds the latest\r\n * state for that hierarchy group For instance, if A < B < C and the state machine leaves C for a\r\n * state in another branch, then `last_seen_state` will be set to C for A, B and C\r\n * - Holds an `active` property which is not so useful so far, and which signal whether the state\r\n * is active (current) or not\r\n * - Tthe root state (NOK) is added to the whole hierarchy, i.e. all states inherit from the root\r\n * state\r\n * `states` {Object<String,Boolean>} : Hash which maps every state name with itself\r\n * `states.history` {Object<String,Function>} : Hash which maps every state name with a function\r\n * whose name is the state name\r\n * @param states\r\n * @returns {{hash_states: {}, is_group_state: {}}}\r\n */\r\nfunction build_nested_state_structure(states, event_emitter_factory) {\r\n  const root_name = 'State';\r\n  const last_seen_state_event_emitter = event_emitter_factory();\r\n  let hash_states = {};\r\n  let last_seen_state_listener_disposables = [];\r\n  let is_group_state = {};\r\n\r\n  // Add the starting state\r\n  states = { nok: states };\r\n\r\n  ////////\r\n  // Helper functions\r\n  function add_last_seen_state_listener(child_name, parent_name) {\r\n    last_seen_state_listener_disposables.push(\r\n      last_seen_state_event_emitter.subscribe(function (x) {\r\n        const event_emitter_name = x.event_emitter_name\r\n        const last_seen_state_name = x.last_seen_state_name;\r\n        if (event_emitter_name === child_name) {\r\n          console.log(['last seen state set to', wrap(last_seen_state_name), 'in', wrap(parent_name)].join(\" \"));\r\n          hash_states[parent_name].history.last_seen_state = last_seen_state_name;\r\n        }\r\n      }));\r\n  }\r\n\r\n  function build_state_reducer(states, curr_constructor) {\r\n    keys(states).forEach(function (state_name) {\r\n      const state_config = states[state_name];\r\n      let curr_constructor_new;\r\n\r\n      // The hierarchical state mechanism is implemented by reusing the standard Javascript\r\n      // prototypal inheritance If A < B < C, then C has a B as prototype which has an A as\r\n      // prototype So when an event handler (transition) is put on A, that event handler will be\r\n      // visible in B and C\r\n      hash_states[state_name] = new curr_constructor();\r\n      hash_states[state_name].name = state_name;\r\n      const parent_name = hash_states[state_name].parent_name = get_fn_name(curr_constructor);\r\n      hash_states[state_name].root_name = root_name;\r\n      hash_states[state_name].history = { last_seen_state: null };\r\n      hash_states[state_name].active = false;\r\n\r\n      // Set up the listeners for propagating the last seen state up the prototypal chain\r\n      // Prototypal inheritance only works in one direction, we need to implement the other\r\n      // direction by hand if A < B < C is a state hierarchy, to implement correctly the history\r\n      // mechanism, we need the last seen state to be the same throughout the whole hierarchy.\r\n      // Prototypal inheritance does not help here as it works in the opposite direction. So we\r\n      // resort to an event emitter (here an RxJS subject) which connect C and B, B and A. When\r\n      // state C is abandoned, then it updates it `last_seen_state` property and emits a change\r\n      // event, B is subscribed to it, and updates its property and emits a change. A is subscribed\r\n      // to B changes, so that the change event is propagated recursively up the hierarchy. This is\r\n      // a reactive mechanim which is simpler that the interactive one where you adjust the whole\r\n      // hierarchy when state C is abandoned.\r\n      add_last_seen_state_listener(state_name, parent_name);\r\n\r\n      if (typeof(state_config) === 'object') {\r\n        is_group_state[state_name] = true;\r\n        eval(['curr_constructor_new = function', state_name, '(){}'].join(\" \"));\r\n        curr_constructor_new.displayName = state_name;\r\n        curr_constructor_new.prototype = hash_states[state_name];\r\n        build_state_reducer(state_config, curr_constructor_new);\r\n      }\r\n    })\r\n  }\r\n\r\n  function State() {\r\n    this.history = { last_seen_state: null };\r\n  }\r\n\r\n  // The `emitLastSeenStateEvent` is set on the State object which is inherited by all state\r\n  // objects, so it can be called from all of them when a transition triggers a change of state\r\n  State.prototype = {\r\n    emitLastSeenStateEvent: function (x) {\r\n      last_seen_state_event_emitter.onNext(x);\r\n    },\r\n    current_state_name: INITIAL_STATE_NAME\r\n  };\r\n\r\n  hash_states[INITIAL_STATE_NAME] = new State();\r\n  hash_states[STATE_PROTOTYPE_NAME] = new State();\r\n\r\n  build_state_reducer(states, State);\r\n\r\n  return {\r\n    hash_states: hash_states,\r\n    is_group_state: is_group_state\r\n  };\r\n}\r\n\r\n/**\r\n * Returns a hash which maps a state name to :\r\n * - a string identifier which represents the standard state\r\n * - a function whose name is the state name to represent the state history (set in the `history`\r\n * property of the hash)\r\n * @param states A hash describing a hierarchy of nested states\r\n * @returns {state_name: {String}, {history: {Function}}}\r\n */\r\nfunction build_state_enum(states) {\r\n  let states_enum = { history: {} };\r\n\r\n  // Set initial state\r\n  states_enum.NOK = INITIAL_STATE_NAME;\r\n\r\n  function build_state_reducer(states) {\r\n    keys(states).forEach(function (state_name) {\r\n      const state_config = states[state_name];\r\n\r\n      states_enum[state_name] = state_name;\r\n      // All history states will be signalled through the history property, and a function instead\r\n      // of a value The function name is the state name whose history is referred to\r\n      let state_name_history_fn;\r\n      // NOTE : we add an underscore to avoid collision with javascript reserved word (new,\r\n      // each, ...)\r\n      eval(['state_name_history_fn = function', '_' + state_name, '(){}'].join(\" \"));\r\n      states_enum.history[state_name] = state_name_history_fn;\r\n\r\n      if (typeof(state_config) === 'object') {\r\n        build_state_reducer(state_config);\r\n      }\r\n    })\r\n  }\r\n\r\n  build_state_reducer(states);\r\n\r\n  return states_enum;\r\n}\r\n\r\n/**\r\n * TODO : DOC transition mechanism\r\n * - transition format\r\n *   - events : if not present, then actions become automatic\r\n *   // DOC : only document the array : always array even if only one condition\r\n *   - condition(s) : if several, pass them in an array (field `conditions`), the order of the\r\n * array is the order of applying the conditions. When a single condition (field `condition`) When\r\n * the first is found true, the sequence of condition checking stops there\r\n *   - action : function (model, event_data, settings) : {output, update_state}\r\n *   - from : state from which the described transition operates\r\n *   - to : target state for the described transition\r\n * @param {FSM_Def} fsmDef\r\n * @param {{subject_factory: Function, merge: Function}} settings Contains the subject factory as mandatory settings,\r\n * and any other. The `merge` settings is mandatory only when using th streaming state machine functionality\r\n * extra settings the API user wants to make available in state machine's scope\r\n * @returns {{yield : Function, start: Function}}\r\n */\r\nexport function create_state_machine(fsmDef, settings) {\r\n  const { states: control_states, events, transitions, initial_extended_state } = fsmDef;\r\n  const subject_factory = settings && settings.subject_factory;\r\n  if (!subject_factory) throw `create_state_machine : cannot find a subject factory (use Rxjs subject??)`\r\n\r\n  const _control_states = build_state_enum(control_states);\r\n  const _events = build_event_enum(events);\r\n\r\n  // Create the nested hierarchical\r\n  const hash_states_struct = build_nested_state_structure(_control_states, subject_factory);\r\n\r\n  // This will be the model object which will be updated by all actions and on which conditions\r\n  // will be evaluated It is safely contained in a closure so it cannot be accessed in any way\r\n  // outside the state machine. Note also that the model is only modified through JSON patch operations which create\r\n  // a new model every time. There is hence no need to do any cloning.\r\n  let model = initial_extended_state;\r\n  let is_init_state = {}; // {Object<state_name,boolean>}, allows to know whether a state has a\r\n  // init transition defined\r\n  let is_auto_state = {}; // {Object<state_name,boolean>}, allows to know whether a state has an\r\n  // automatic transition defined\r\n  const is_group_state = hash_states_struct.is_group_state; // {Object<state_name,boolean>}, allows\r\n                                                            // to know whether a state is a group\r\n                                                            // of state or not\r\n  let hash_states = hash_states_struct.hash_states;\r\n\r\n  transitions.forEach(function (transition) {\r\n    console.log(\"processing transition:\", transition);\r\n    let { from, to, action, event, guards: arr_predicate } = transition;\r\n    // CASE : ZERO OR ONE condition set\r\n    if (!arr_predicate) arr_predicate = [\r\n      { predicate: arr_predicate, to: to, action: action }\r\n    ];\r\n\r\n    // CASE : transition has a init event\r\n    // NOTE : there should ever only be one, but we don't enforce it for now\r\n    if (event === INIT_EVENT) {\r\n      is_init_state[from] = true;\r\n    }\r\n\r\n    let from_proto = hash_states[from];\r\n\r\n    // ERROR CASE : state found in transition but cannot be found in the events passed as parameter\r\n    // NOTE : this is probably all what we need the events variable for\r\n    if (event && !(event in _events)) throw `unknown event ${event} found in state machine definition!`\r\n    // CASE : automatic transitions : no events - likely a transient state with only conditions\r\n    if (!event) {\r\n      event = AUTO_EVENT;\r\n      is_auto_state[from] = true;\r\n    }\r\n    // CASE : automatic transitions : init event automatically fired upon entering a grouping state\r\n    if (is_group_state[from] && is_init_state[from]) {\r\n      is_auto_state[from] = true;\r\n    }\r\n\r\n    console.log(\"This is transition for event:\", event);\r\n    console.log(\"Predicates:\", arr_predicate);\r\n\r\n    from_proto[event] = arr_predicate.reduce(function (acc, guard, index) {\r\n      let action = guard.action;\r\n      console.log(\"Guard:\", guard);\r\n      const condition_checking_fn = (function (guard, settings) {\r\n        let condition_suffix = '';\r\n        // We add the `current_state` because the current state might be different from the `from`\r\n        // field here This is the case for instance when we are in a substate, but through\r\n        // prototypal inheritance it is the handler of the prototype which is called\r\n        const condition_checking_fn = function (model_, event_data, current_state) {\r\n          from = current_state || from;\r\n          const { predicate, to } = guard;\r\n          condition_suffix = predicate ? '_checking_condition_' + index : '';\r\n          let actionResult = default_action_result;\r\n\r\n          if (!predicate || predicate(model_, event_data, settings)) {\r\n            // CASE : guard for transition is fulfilled so we can execute the actions...\r\n            console.info(\"IN STATE \", from);\r\n            console.info(\"WITH model, event data, settings BEING \", model_, event_data, settings);\r\n            console.info(\"CASE : \"\r\n              + (predicate ? \"guard \" + predicate.name + \" for transition is fulfilled\"\r\n                : \"automatic transition\"));\r\n            if (action) {\r\n              // CASE : we do have some actions to execute\r\n              console.info(\"THEN : we execute the action \" + action.name);\r\n              // NOTE : in a further extension, passing the fsm and the events object could help\r\n              // in implementing asynchronous fsm\r\n              actionResult = action(model_, event_data, settings);\r\n            }\r\n\r\n            // Leave the current state\r\n            leave_state(from, model_, hash_states);\r\n\r\n            // Update the model before entering the next state\r\n            model = update_model(model_, actionResult.model_update);\r\n            // Emit the new model event\r\n            // new_model_event_emitter.onNext(model);\r\n            console.info(\"RESULTING IN : \", model);\r\n            console.info(\"RESULTING IN OUTPUT : \", actionResult.output);\r\n\r\n            // ...and enter the next state (can be different from to if we have nesting state group)\r\n            const next_state = enter_next_state(to, actionResult.model_update, hash_states);\r\n            console.info(\"ENTERING NEXT STATE : \", next_state);\r\n\r\n            return { stop: true, output: actionResult.output }; // allows for chaining and stop\r\n                                                                // chaining guard\r\n          }\r\n          else {\r\n            // CASE : guard for transition is not fulfilled\r\n            console.log(\"CASE : \"\r\n              + (predicate ? \"guard \" + predicate.name + \" for transition NOT fulfilled...\"\r\n                : \"no predicate\"));\r\n            return { stop: false, output: NO_OUTPUT };\r\n          }\r\n        };\r\n        condition_checking_fn.displayName = from + condition_suffix;\r\n        return condition_checking_fn;\r\n      })(guard, settings);\r\n\r\n      return function arr_predicate_reduce_fn(model_, event_data, current_state) {\r\n        const condition_checked = acc(model_, event_data, current_state);\r\n        return condition_checked.stop\r\n          ? condition_checked\r\n          : condition_checking_fn(model_, event_data, current_state);\r\n      }\r\n    }, function dummy() {\r\n      return { stop: false, output: NO_OUTPUT }\r\n    });\r\n  });\r\n\r\n  function send_event(event_struct) {\r\n    console.log(\"send event\", event_struct);\r\n    const event_name = keys(event_struct)[0];\r\n    const event_data = event_struct[event_name];\r\n\r\n    return process_event(hash_states_struct.hash_states, event_name, event_data, model);\r\n  }\r\n\r\n  function process_event(hash_states, event, event_data, model) {\r\n    console.log(\"Processing event \", event, event_data);\r\n    const current_state = hash_states[INITIAL_STATE_NAME].current_state_name;\r\n    const event_handler = hash_states[current_state][event];\r\n\r\n    if (event_handler) {\r\n      // CASE : There is a transition associated to that event\r\n      console.log(\"found event handler!\");\r\n      console.info(\"WHEN EVENT \", event);\r\n      /* OUT : this event handler modifies the model and possibly other data structures */\r\n      const output = event_handler(model, event_data, current_state).output;\r\n\r\n      // we read it anew as the execution of the event handler may have changed it\r\n      const current_state = hash_states[INITIAL_STATE_NAME].current_state_name;\r\n\r\n      // Two cases here:\r\n      // 1. Init handlers, when present on the current state, must be acted on immediately\r\n      // This allows for sequence of init events in various state levels\r\n      // For instance, L1: init -> L2:init -> L3:init -> L4: stateX\r\n      // In this case event_data will carry on the data passed on from the last event (else we loose\r\n      // the model?) 2. transitions with no events associated, only conditions (i.e. transient\r\n      // states) In this case, there is no need for event data\r\n      if (is_auto_state[current_state]) {\r\n        // CASE : transient state with no triggering event, just conditions\r\n        // automatic transitions = transitions without events\r\n        const auto_event = is_init_state[current_state] ? INIT_EVENT : AUTO_EVENT;\r\n        return send_event({ [AUTO_EVENT]: event_data });\r\n      }\r\n      else return output\r\n    }\r\n    else {\r\n      // CASE : There is no transition associated to that event from that state\r\n      console.error(`There is no transition associated to that event!`);\r\n\r\n      return NO_OUTPUT;\r\n    }\r\n  }\r\n\r\n  function leave_state(from, model, hash_states) {\r\n    // NOTE : model is passed as a parameter for symetry reasons, no real use for it so far\r\n    const state_from = hash_states[from];\r\n    const state_from_name = state_from.name;\r\n\r\n    // Set the `last_seen_state` property in the object representing that state's state (!)...\r\n    state_from.history.last_seen_state = state_from_name;\r\n    state_from.active = false;\r\n    console.log(\"left state\", wrap(from));\r\n\r\n    // ... and emit the change event for the parents up the hierarchy to update also their\r\n    // last_seen_state properties This updating solution is preferred to an imperative solution, as\r\n    // it allows not to think too much about how to go up the hierarchy There is no big difference\r\n    // also, as by default subject emits synchronously their values to all subscribers. The\r\n    // difference in speed should be neglectable, and anyways it is not expected to have large\r\n    // state chart depths\r\n    state_from.emitLastSeenStateEvent({\r\n      event_emitter_name: state_from_name,\r\n      last_seen_state_name: state_from_name\r\n    });\r\n  }\r\n\r\n  function enter_next_state(to, model_prime, hash_states) {\r\n    // Enter the target state\r\n    let state_to;\r\n    let state_to_name;\r\n    // CASE : history state (H)\r\n    if (typeof(to) === 'function') {\r\n      state_to_name = get_fn_name(to);\r\n\r\n      const target_state = hash_states[state_to_name].history.last_seen_state;\r\n      state_to_name = target_state\r\n        // CASE : history state (H) && existing history, target state is the last seen state\r\n        ? target_state\r\n        // CASE : history state (H) && no history (i.e. first time state is entered), target state\r\n        // is the entered state\r\n        : state_to_name;\r\n      state_to = hash_states[state_to_name];\r\n    }\r\n    // CASE : normal state\r\n    else if (to) {\r\n      state_to = hash_states[to];\r\n      state_to_name = state_to.name;\r\n    }\r\n    else {\r\n      throw 'enter_state : unknown case! Not a state name, and not a history state to enter!'\r\n    }\r\n    state_to.active = true;\r\n    hash_states[INITIAL_STATE_NAME].current_state_name = state_to_name;\r\n\r\n    console.info(\"AND TRANSITION TO STATE\", state_to_name);\r\n    return state_to_name;\r\n  }\r\n\r\n  function start() {\r\n    return send_event({ [INIT_EVENT]: initial_extended_state });\r\n  }\r\n\r\n  /**\r\n   * OUT\r\n   * @param model\r\n   * @param modelUpdateOperations\r\n   */\r\n  function update_model(model, modelUpdateOperations) {\r\n    return applyUpdateOperations(model, modelUpdateOperations);\r\n  }\r\n\r\n  return {\r\n    yield: send_event,\r\n    start: start,\r\n  }\r\n}\r\n\r\n/**\r\n *\r\n * @param {{subject_factory: Function, merge: Function, of:Function}} settings Contains the `merge` property as\r\n * mandatory\r\n * @param {FSM_Def} fsmDef\r\n * settings. That merge function must take an array of observables and return an observable.\r\n * Otherwise can also hold extra settings the API user wants to make available in state machine's scope\r\n * @returns {function(Object<String, Rx.Observable>): *}\r\n */\r\nexport function makeStreamingStateMachine(settings, fsmDef) {\r\n  const fsm = create_state_machine(fsmDef, settings);\r\n  const merge = settings && settings.merge;\r\n  const of = settings && settings.of;\r\n  if (!merge || !of) throw `makeStreamingStateMachine : could not find an observable merge or of functions ! use Rx??`\r\n\r\n  /**\r\n   * @param {Object.<Event_Label, Rx.Observable>} events A mapping of event labels to the corresponding event sources\r\n   * @returns {Rx.Observable} Returns an observable containing the actions emitted by the state machine in response\r\n   * to the specified input events\r\n   */\r\n  const computeActions = function computeActions(events) {\r\n    return merge(\r\n      // Contract : the `merge` function must subscribe to its source parameters in order of appearance\r\n      // This ensures that the init event is indeed processed always before the other events\r\n      of({[INIT_EVENT] : fsmDef.initial_extended_state}),\r\n      keys(events).map(eventLabel => {\r\n        const eventSource$ = events[eventLabel];\r\n        return eventSource$.map(eventData => fsm.yield({ [eventLabel]: eventData }))\r\n      })\r\n    )\r\n      .filter(output => output != NO_OUTPUT)\r\n  }\r\n\r\n  return computeActions\r\n}\r\n\r\n// TODO DOC: explain hierarchy, initial events, auto events, and other contracts\r\n// TODO DOC: document the obs merge settings (+filter necessary on prototype)\r\n\r\n\r\n/* test plan\r\nCase non-hierarchical state machine :\r\nA -> B with event[ guard ] / action\r\naction -> {update state, output] | exception\r\nupdate_state = [no update, update 1, update 2, malformed] (I need to update to test composition of updates. Ideally they should be chosen such that order matters, and not idempotent (use JSON patch push possibility))\r\noutput = [no output, {model, event_data} - not cloned, to check immutable, malformed]\r\nevent -> [init, event1, event2, unknown event]\r\nguard -> [T, F, exception]\r\n// TODO : I should also clone settings prior to usage, so it is not modified later on inadvertently\r\n\r\n  Then Machines = [States x Transitions x event[ guard ] / action]\r\n    States in [Init, State1, State2, State3]\r\n    Transitions in [pick two states in States possibly the same]\r\n\r\nSo stage 1 : input generation\r\n   Stage 2 : for the generated input, guess the right result and then check vs. actual run\r\n\r\nEdge case : malformed state machine : write checker of well-formed (to test too then...)\r\n\r\nSo Model based Testing algorithm :\r\n- accumulator initialized to null\r\n- generate set of states -> accumulator\r\n- generate set of transitions -> accumulator\r\n- generate event sequence -> accumulator\r\n- generate guard -> accumulator\r\n- generate actions -> accumulator\r\n\r\nNow I want to generate some more interesting cases than other, rather than go with exhaustive testing\r\n*/\r\n","const PATH_ROOT = [0];\r\nexport const POST_ORDER = \"POST_ORDER\";\r\nexport const PRE_ORDER = \"PRE_ORDER\";\r\nexport const BFS = \"BFS\";\r\nexport const SEP = \".\";\r\n\r\n///// Utility functions\r\n// Cheap cloning, which is enough for our needs : we only clone seeds and empty values, which are generally simple\r\n// objects\r\nfunction clone(a) {\r\n  return a === undefined ? undefined : JSON.parse(JSON.stringify(a))\r\n}\r\n\r\nfunction merge(objA, objB) {\r\n  return Object.assign({}, objA, objB);\r\n}\r\n\r\nfunction times(fn, n) {\r\n  return Array.apply(null, { length: n }).map(Number.call, Number).map(fn)\r\n}\r\n\r\nconst stringify = path => path.join(SEP);\r\n\r\n/**\r\n *\r\n * @param {Map} traversalState\r\n * @param subTree\r\n * @param {Array} subTreeChildren\r\n * @modifies {traversalState}\r\n */\r\nfunction updatePathInTraversalState(traversalState, subTree, subTreeChildren) {\r\n  subTreeChildren.forEach((subTreeChild, index) => {\r\n    const traversalStateParent = traversalState.get(subTree);\r\n    // NOTE : if the path is already set we do not modify it. This allows for post-order traversal, which puts back\r\n    // the parent node into the children nodes to keep the original path for the parent node. So at any time, the\r\n    // `path` value can be trusted to be accurately describing the location of the node in the tree\r\n    const traversalStateChild = traversalState.get(subTreeChild);\r\n    const currentChildPath = traversalStateChild && traversalStateChild.path;\r\n\r\n    traversalState.set(\r\n      subTreeChild,\r\n      merge(traversalStateChild, {\r\n        isAdded: true,\r\n        isVisited: false,\r\n        path: currentChildPath || traversalStateParent.path.concat(index)\r\n      })\r\n    );\r\n  });\r\n}\r\n\r\n/**\r\n *\r\n * @param {Map} traversalState\r\n * @param tree\r\n * @modifies {traversalState}\r\n */\r\nfunction updateVisitInTraversalState(traversalState, tree) {\r\n  traversalState.set(\r\n    tree,\r\n    merge(traversalState.get(tree), { isVisited: true })\r\n  );\r\n}\r\n\r\n///// Core API\r\nexport function visitTree(traversalSpecs, tree) {\r\n  const { store, lenses, traverse } = traversalSpecs;\r\n  const { empty: emptyOrEmptyConstructor, add, takeAndRemoveOne, isEmpty } = store;\r\n  const { getChildren } = lenses;\r\n  const { visit, seed: seedOrSeedConstructor } = traverse;\r\n  const traversalState = new Map();\r\n  // NOTE : This allows to have seeds which are non-JSON objects, such as new Map(). We force a new here to make\r\n  // sure we have an object that cannot be modified out of the scope of visitTree and collaborators\r\n  const seed = (typeof seedOrSeedConstructor === 'function') ? new (seedOrSeedConstructor()) : clone(seedOrSeedConstructor);\r\n  const empty = (typeof emptyOrEmptyConstructor === 'function') ? new (emptyOrEmptyConstructor()) : clone(emptyOrEmptyConstructor);\r\n\r\n  let currentStore = empty;\r\n  let visitAcc = seed;\r\n  add([tree], currentStore);\r\n  traversalState.set(tree, { isAdded: true, isVisited: false, path: PATH_ROOT });\r\n\r\n  while ( !isEmpty(currentStore) ) {\r\n    const subTree = takeAndRemoveOne(currentStore);\r\n    const subTreeChildren = getChildren(traversalState, subTree);\r\n\r\n    add(subTreeChildren, currentStore);\r\n    updatePathInTraversalState(traversalState, subTree, subTreeChildren);\r\n    visitAcc = visit(visitAcc, traversalState, subTree);\r\n    updateVisitInTraversalState(traversalState, subTree);\r\n  }\r\n\r\n  // Free the references to the tree/subtrees\r\n  traversalState.clear();\r\n\r\n  return visitAcc;\r\n}\r\n\r\nexport function breadthFirstTraverseTree(lenses, traverse, tree) {\r\n  const { getChildren } = lenses;\r\n  const traversalSpecs = {\r\n    store: {\r\n      empty: [],\r\n      takeAndRemoveOne: store => store.shift(),\r\n      isEmpty: store => store.length === 0,\r\n      add: (subTrees, store) => store.push.apply(store, subTrees)\r\n    },\r\n    lenses: { getChildren: (traversalState, subTree) => getChildren(subTree) },\r\n    traverse\r\n  };\r\n\r\n  return visitTree(traversalSpecs, tree);\r\n}\r\n\r\nexport function preorderTraverseTree(lenses, traverse, tree) {\r\n  const { getChildren } = lenses;\r\n  const traversalSpecs = {\r\n    store: {\r\n      empty: [],\r\n      takeAndRemoveOne: store => store.shift(),\r\n      isEmpty: store => store.length === 0,\r\n      // NOTE : vs. bfs, only `add` changes\r\n      add: (subTrees, store) => store.unshift(...subTrees)\r\n    },\r\n    lenses: { getChildren: (traversalState, subTree) => getChildren(subTree) },\r\n    traverse\r\n  };\r\n\r\n  return visitTree(traversalSpecs, tree);\r\n}\r\n\r\nexport function postOrderTraverseTree(lenses, traverse, tree) {\r\n  const { getChildren } = lenses;\r\n  const isLeaf = (tree, traversalState) => getChildren(tree, traversalState).length === 0;\r\n  const { seed, visit } = traverse;\r\n  const predicate = (tree, traversalState) => traversalState.get(tree).isVisited || isLeaf(tree, traversalState)\r\n  const decoratedLenses = {\r\n    // For post-order, add the parent at the end of the children, that simulates the stack for the recursive function\r\n    // call in the recursive post-order traversal algorithm\r\n    // DOC : getChildren(tree, traversalState) also admit traversalState as argumnets but in second place\r\n    getChildren: (traversalState, tree) =>\r\n      predicate(tree, traversalState)\r\n        ? []\r\n        : getChildren(tree, traversalState).concat([tree])\r\n  };\r\n  const traversalSpecs = {\r\n    store: {\r\n      empty: [],\r\n      takeAndRemoveOne: store => store.shift(),\r\n      isEmpty: store => store.length === 0,\r\n      add: (subTrees, store) => store.unshift(...subTrees)\r\n    },\r\n    lenses: decoratedLenses,\r\n    traverse: {\r\n      seed: seed,\r\n      visit: (result, traversalState, tree) => {\r\n        // Cases :\r\n        // 1. label has been visited already : visit\r\n        // 2. label has not been visited, and there are no children : visit\r\n        // 3. label has not been visited, and there are children : don't visit, will do it later\r\n        return predicate(tree, traversalState)\r\n        ? visit(result, traversalState, tree)\r\n          : result\r\n      }\r\n    }\r\n  };\r\n\r\n  return visitTree(traversalSpecs, tree);\r\n}\r\n\r\n/**\r\n *\r\n * @param {{getChildren : function}} lenses\r\n * @param {{strategy : *, seed : *, visit : function}} traverse\r\n * @param tree\r\n * @returns {*}\r\n */\r\nexport function reduceTree(lenses, traverse, tree) {\r\n  const strategy = traverse.strategy;\r\n  const strategies = {\r\n    BFS: breadthFirstTraverseTree,\r\n    PRE_ORDER: preorderTraverseTree,\r\n    POST_ORDER: postOrderTraverseTree\r\n  };\r\n\r\n  if (!(strategy in strategies)) throw `Unknown tree traversal strategy!`;\r\n\r\n  return strategies[strategy](lenses, traverse, tree);\r\n}\r\n\r\n/**\r\n * Applies a function to every node of a tree. Note that the traversal strategy does matter, as the function to\r\n * apply might perform effects.\r\n * @param {{getChildren : function}} lenses\r\n * @param {{strategy : *, action : function}} traverse\r\n * @param tree\r\n * @returns {*}\r\n */\r\nexport function forEachInTree(lenses, traverse, tree) {\r\n  const { strategy, action } = traverse;\r\n\r\n  const strategies = {\r\n    [BFS]: breadthFirstTraverseTree,\r\n    [PRE_ORDER]: preorderTraverseTree,\r\n    [POST_ORDER]: postOrderTraverseTree\r\n  };\r\n\r\n  if (!(strategy in strategies)) throw `Unknown tree traversal strategy!`;\r\n\r\n  const treeTraveerse = {\r\n    seed: void 0,\r\n    visit: (accumulator, traversalState, tree) => action(tree, traversalState)\r\n  };\r\n  return strategies[strategy](lenses, treeTraveerse, tree);\r\n}\r\n\r\n/**\r\n * Applies a function to every node of a tree, while keeping the tree structure. Note that the traversal strategy in\r\n * that case does not matter, as all nodes will be traversed anyway, and the function to apply is assumed to be a\r\n * pure function.\r\n * @param {{getChildren : function, getLabel : function, constructTree: function}} lenses\r\n * @param {function} mapFn Function to apply to each node.\r\n * @param tree\r\n * @returns {*}\r\n */\r\nexport function mapOverTree(lenses, mapFn, tree) {\r\n  const { getChildren, constructTree, getLabel } = lenses;\r\n  const getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n  const stringify = path => path.join(SEP);\r\n  const treeTraverse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      const { path } = traversalState.get(tree);\r\n      // Paths are *stringified* because Map with non-primitive objects uses referential equality\r\n      const mappedLabel = mapFn(getLabel(tree));\r\n      const mappedChildren = times(\r\n        index => pathMap.get(stringify(path.concat(index))), getChildrenNumber(tree, traversalState));\r\n      const mappedTree = constructTree(mappedLabel, mappedChildren);\r\n\r\n      pathMap.set(stringify(path), mappedTree);\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n  const pathMap = postOrderTraverseTree(lenses, treeTraverse, tree);\r\n  const mappedTree = pathMap.get(stringify(PATH_ROOT));\r\n  pathMap.clear();\r\n\r\n  return mappedTree;\r\n}\r\n\r\n/**\r\n * Returns a tree where all children of nodes which fails a predicate are pruned. Note that the node failing the\r\n * predicate will remain in the tree : only the children will be pruned. If it is wanted to prune also the failing\r\n * node in addition to its children, the `getChildren` function can make use of the second parameter\r\n * `traversalState` to do so\r\n * @param lenses\r\n * @param {function} predicate\r\n * @param tree\r\n * @returns tree\r\n */\r\nexport function pruneWhen(lenses, predicate, tree) {\r\n  // As we need to return a tree, it will be convenient to use mapOverTree\r\n  const { getChildren } = lenses;\r\n  const pruneLenses = merge(lenses, {\r\n    getChildren: (tree, traversalState) => {\r\n      if (predicate(tree, traversalState)) {\r\n        // prune that branch\r\n        return []\r\n      }\r\n      else {\r\n        return getChildren(tree, traversalState)\r\n      }\r\n    }\r\n  });\r\n  const prunedTree = mapOverTree(pruneLenses, x => x, tree);\r\n\r\n  return prunedTree\r\n}\r\n\r\n// Examples of lenses\r\n\r\n// HashedTreeLenses\r\nexport function getHashedTreeLenses(sep) {\r\n  function makeChildCursor(parentCursor, childIndex, sep) {\r\n    return [parentCursor, childIndex].join(sep)\r\n  }\r\n\r\n  return {\r\n    getLabel: tree => {\r\n      const { cursor, hash } = tree;\r\n      return { label: hash[cursor], hash, cursor }\r\n    },\r\n    getChildren: tree => {\r\n      const { cursor, hash } = tree;\r\n      let childIndex = 0;\r\n      let children = [];\r\n\r\n      while ( makeChildCursor(cursor, childIndex, sep) in hash ) {\r\n        children.push({ cursor: makeChildCursor(cursor, childIndex, sep), hash })\r\n        childIndex++;\r\n      }\r\n\r\n      return children\r\n    },\r\n    constructTree: (label, children) => {\r\n      const { label: value, hash, cursor } = label;\r\n\r\n      return {\r\n        cursor: cursor,\r\n        hash: merge(\r\n          children.reduce((acc, child) => merge(acc, child.hash), {}),\r\n          { [cursor]: value }\r\n        )\r\n      }\r\n    },\r\n  };\r\n}\r\n\r\nexport function mapOverHashTree(sep, mapFn, obj) {\r\n  const lenses = getHashedTreeLenses(sep);\r\n\r\n  return mapOverTree(lenses, ({ label, hash, cursor }) => ({\r\n    label: mapFn(label), hash, cursor\r\n  }), obj);\r\n}\r\n\r\n// Object as a tree\r\nexport const objectTreeLenses = {\r\n  getLabel: tree => {\r\n    if (typeof tree === 'object' && !Array.isArray(tree) && Object.keys(tree).length === 1) {\r\n      return tree;\r\n    }\r\n    else {\r\n      throw `getLabel > unexpected object tree value`\r\n    }\r\n  },\r\n  getChildren: tree => {\r\n    if (typeof tree === 'object' && !Array.isArray(tree) && Object.keys(tree).length === 1) {\r\n      let value = Object.values(tree)[0];\r\n      if (typeof value === 'object' && !Array.isArray(value)) {\r\n        return Object.keys(value).map(prop => ({ [prop]: value[prop] }))\r\n      }\r\n      else {\r\n        return []\r\n      }\r\n    }\r\n    else {\r\n      throw `getChildren > unexpected value`\r\n    }\r\n  },\r\n  constructTree: (label, children) => {\r\n    const labelKey = label && Object.keys(label) && Object.keys(label)[0];\r\n\r\n    return children.length === 0\r\n      ? label\r\n      : {\r\n      [labelKey]: Object.assign.apply(null, children)\r\n    }\r\n  },\r\n};\r\n\r\nexport function mapOverObj({ key: mapKeyfn, leafValue: mapValuefn }, obj) {\r\n  const rootKey = 'root';\r\n  const rootKeyMap = mapKeyfn(rootKey);\r\n\r\n  const mapped =  mapOverTree(objectTreeLenses, (tree) => {\r\n    const key = Object.keys(tree)[0];\r\n    const value = tree[key];\r\n\r\n    return {\r\n      [mapKeyfn(key)]: isLeafLabel(objectTreeLenses.getLabel(tree)) && !isEmptyObject(value)\r\n        ? mapValuefn(value)\r\n        : value\r\n    }\r\n  }, { root: obj });\r\n\r\n  return mapped[rootKeyMap];\r\n}\r\n\r\nfunction isLeafLabel(label) { return objectTreeLenses.getChildren({ [label.key]: label.value }).length === 0}\r\n\r\nfunction isEmptyObject(obj) {\r\n  return obj && Object.keys(obj).length === 0 && obj.constructor === Object\r\n}\r\n\r\nexport const arrayTreeLenses = {\r\n  getLabel: tree => {\r\n    return Array.isArray(tree) ? tree[0] : tree\r\n  },\r\n  getChildren: tree => {\r\n    return Array.isArray(tree)  ? tree[1] : []\r\n  },\r\n  constructTree: (label, children) => {\r\n    return children && Array.isArray(children) && children.length > 0 ? [label, children] : label\r\n  },\r\n}\r\n\r\nexport function switchTreeDataStructure(originLenses, targetLenses, tree) {\r\n  const { getLabel, getChildren } = originLenses;\r\n  const { constructTree } = targetLenses;\r\n  const getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n\r\n  const traverse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      const { path } = traversalState.get(tree);\r\n      const label = getLabel(tree);\r\n      const children = times(\r\n        index => pathMap.get(stringify(path.concat(index))),\r\n        getChildrenNumber(tree, traversalState)\r\n      );\r\n      pathMap.set(stringify(path), constructTree(label, children));\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n\r\n  const newTreeStruct = postOrderTraverseTree(originLenses, traverse, tree);\r\n  return newTreeStruct.get(stringify(PATH_ROOT));\r\n}\r\n","import {\r\n  HISTORY_STATE_NAME, INITIAL_STATE_NAME, SEP, TRANSITION_LABEL_START_SYMBOL, TRANSITION_SYMBOL\r\n} from \"./properties\"\r\nimport {\r\n  displayName, format_history_transition_state_name, format_transition_label, get_all_transitions, is_entry_transition,\r\n  is_from_control_state, is_history_transition, is_to_history_control_state_of, times\r\n} from './helpers'\r\nimport { arrayTreeLenses, objectTreeLenses, postOrderTraverseTree } from \"fp-rosetree\"\r\n\r\nfunction generateStatePlantUmlHeader(state, optDisplayName) {\r\n  return optDisplayName\r\n    ? `state \"${optDisplayName}\" as ${state} <<NoContent>>`\r\n    : `state \"${displayName(state)}\" as ${state} <<NoContent>>`\r\n}\r\n\r\n/**\r\n * Converts a transducer definition to a textual format for interpretation by PlantUml tools\r\n * @param {FSM_Def} fsmDef\r\n * @param {*} settings\r\n */\r\nexport function toPlantUml(fsmDef, settings) {\r\n  const { states, transitions } = fsmDef;\r\n  const { getChildren, constructTree, getLabel } = objectTreeLenses;\r\n  const stringify = path => path.join(SEP);\r\n  const getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n  const traverse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      const { path } = traversalState.get(tree);\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      const childrenTranslation = times(\r\n        index => pathMap.get(stringify(path.concat(index))),\r\n        getChildrenNumber(tree, traversalState)\r\n      );\r\n      const translation = stateToPlantUML(controlState, childrenTranslation, transitions);\r\n      pathMap.set(stringify(path), translation);\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n\r\n  const translationMap = postOrderTraverseTree(objectTreeLenses, traverse, { [INITIAL_STATE_NAME]: states });\r\n\r\n  const mappedTree = translationMap.get('0');\r\n  translationMap.clear();\r\n\r\n  return mappedTree;\r\n}\r\n\r\n/**\r\n * Convert a state machine specs into a plantUML format, limiting its conversion scope to a given control state and\r\n * its nested hierarchy\r\n * @param {Control_State} controlState\r\n * @param {Array<String>} childrenTranslation conversion of the states nested in the given control state\r\n * @param {Array<Transition>} transitions Full set of transitions as defined in the state machine specs\r\n * CONTRACT : All control states must have different names...\r\n */\r\nfunction stateToPlantUML(controlState, childrenTranslation, transitions) {\r\n  return [\r\n    `${generateStatePlantUmlHeader(controlState, '')} {`,\r\n    childrenTranslation.join('\\n'),\r\n    format_history_states(controlState, transitions),\r\n    format_entry_transitions(controlState, transitions),\r\n    `}`,\r\n    translate_transitions(controlState, transitions)\r\n  ]\r\n    .filter(x => x !== '\\n' && x !== '')\r\n    .join('\\n');\r\n}\r\n\r\nfunction format_history_states(controlState, transitions) {\r\n  // creates the history states as orig.dest.H\r\n  // e.g.  state \"H\" as CD_stepping_forwards.CD_Loaded_Group.H <<NoContent>>\r\n  const historyStatesObj = transitions.reduce((accTranslation, transition) => {\r\n    const allTransitions = get_all_transitions(transition);\r\n\r\n    return allTransitions\r\n      .filter(is_history_transition)\r\n      .filter(is_to_history_control_state_of(controlState))\r\n      .reduce((acc, transition) => {\r\n        acc[format_history_transition_state_name(transition)] = void 0;\r\n        return acc\r\n      }, accTranslation)\r\n  }, {});\r\n  const historyStates = Object.keys(historyStatesObj);\r\n\r\n  return historyStates.map(historyState => {\r\n    return `${generateStatePlantUmlHeader(historyState, HISTORY_STATE_NAME)}`\r\n  }).join('\\n')\r\n}\r\n\r\nfunction translate_transitions(controlState, transitions) {\r\n  const historyTransitionTranslation = format_history_transitions(controlState, transitions);\r\n  const standardTransitionTranslation = format_standard_transitions(controlState, transitions);\r\n\r\n  return [\r\n    historyTransitionTranslation,\r\n    standardTransitionTranslation\r\n  ]\r\n    .filter(Boolean)\r\n    .join('\\n')\r\n}\r\n\r\nfunction format_standard_transitions(controlState, transitions) {\r\n  // The only transition from initial state are INIT transitions and that's already taken care of elsewhere\r\n  if (controlState === INITIAL_STATE_NAME) return ''\r\n  else return transitions.map(transition => {\r\n    const allTransitions = get_all_transitions(transition)\r\n\r\n    return allTransitions\r\n      .filter(is_from_control_state(controlState))\r\n      .filter(transition => !is_entry_transition(transition))\r\n      .filter(transition => !is_history_transition(transition))\r\n      .map(({ from, event, predicate, to, action }) => {\r\n        return [\r\n          from,\r\n          TRANSITION_SYMBOL,\r\n          to,\r\n          TRANSITION_LABEL_START_SYMBOL,\r\n          format_transition_label(event, predicate, action),\r\n        ].join(' ')\r\n      }).join('\\n');\r\n  })\r\n  // necessary because [].join('\\n') is \"\" so I need to take those out to avoid unnecessary '\\n' down the road\r\n    .filter(Boolean)\r\n    .join('\\n');\r\n}\r\n\r\nfunction format_entry_transitions(controlState, transitions) {\r\n  const translation = transitions.reduce((accTranslation, transition) => {\r\n    const allTransitions = get_all_transitions(transition);\r\n\r\n    return allTransitions\r\n      .filter(is_entry_transition)\r\n      .filter(is_from_control_state(controlState))\r\n      .reduce((acc, transition) => {\r\n        const { from, to, predicate, action } = transition;\r\n        acc.push(\r\n          `[*] ${TRANSITION_SYMBOL} ${to} ${TRANSITION_LABEL_START_SYMBOL} ${format_transition_label(\"\", predicate, action)}`\r\n        );\r\n        return acc\r\n      }, accTranslation)\r\n  }, []);\r\n\r\n  return translation.join('\\n')\r\n}\r\n\r\nfunction format_history_transitions(controlState, transitions) {\r\n  return transitions.map(transition => {\r\n    const allTransitions = get_all_transitions(transition)\r\n\r\n    return allTransitions\r\n      .filter(is_from_control_state(controlState))\r\n      .filter(is_history_transition)\r\n      .map(({ from, event, predicate, to, action }) => {\r\n        return [\r\n          from,\r\n          TRANSITION_SYMBOL,\r\n          format_history_transition_state_name({ from, to }),\r\n          TRANSITION_LABEL_START_SYMBOL,\r\n          format_transition_label(event, predicate, action),\r\n        ].join(' ')\r\n      }).join('\\n');\r\n  })\r\n    .filter(Boolean)\r\n    .join('\\n');\r\n}\r\n\r\nexport function toDagreVisualizerFormat(fsmDef) {\r\n  // only thing to do here is to replace functions (guards and actions) by their name, and keep only\r\n  // the states and transitions properties\r\n  // ah no I also need to turn the states obj tree into an array-based tree... grrr\r\n  const { states, transitions } = fsmDef;\r\n  const { getLabel, getChildren } = objectTreeLenses;\r\n  const { constructTree } = arrayTreeLenses;\r\n  const getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n  const stringify = path => path.join(SEP);\r\n  const traverse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      const { path } = traversalState.get(tree);\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      const children = times(\r\n        index => pathMap.get(stringify(path.concat(index))),\r\n        getChildrenNumber(tree, traversalState)\r\n      );\r\n      pathMap.set(stringify(path), constructTree(controlState, children));\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n\r\n  const _translatedStates = postOrderTraverseTree(objectTreeLenses, traverse, { [INITIAL_STATE_NAME]: states });\r\n  const translatedStates = _translatedStates.get('0');\r\n\r\n  const translatedTransitions = transitions.map(transition => {\r\n    const { from, to, event, guards, action } = transition;\r\n    if (guards) {\r\n      const translatedGuards = guards.map(guard => {\r\n        const { predicate, to, action } = guard;\r\n        return { predicate: predicate.name, to, action: action.name }\r\n      })\r\n      return { from, event, guards: translatedGuards }\r\n    }\r\n    else {\r\n      // case {from, to event, action}\r\n      return { from, to, event, action: action.name || 'no action name?' }\r\n    }\r\n  });\r\n\r\n  return JSON.stringify({ states: translatedStates, transitions: translatedTransitions })\r\n}\r\n"],"names":["CONTRACT_MODEL_UPDATE_FN_RETURN_VALUE","SEP","TRANSITION_SYMBOL","TRANSITION_LABEL_START_SYMBOL","HISTORY_STATE_NAME","HISTORY_PREFIX","INITIAL_STATE_NAME","INIT_EVENT","AUTO_EVENT","STATE_PROTOTYPE_NAME","NO_MODEL_UPDATE","NO_OUTPUT","default_action_result","model_update","output","pSlice","Array","prototype","slice","objectKeys","Object","keys","isArguments","object","toString","call","isUndefinedOrNull","value","isBuffer","x","length","copy","objEquiv","a","b","opts","i","key","deepEqual","ka","kb","e","sort","actual","expected","Date","getTime","strict","__extends","d","p","hasOwnProperty","__","this","constructor","create","_hasOwnProperty","obj","_objectKeys","isArray","k","push","_deepClone","JSON","parse","stringify","isInteger","str","charCode","len","charCodeAt","unescapePathComponent","path","replace","hasUndefined","undefined","objKeys","objKeysLength","PatchError","_super","message","name","index","operation","tree","Error","equalsOptions","areEquals","_equals","JsonPatchError","objOps","add","document","newDocument","remove","removed","move","getValueByPointer","originalValue","applyOperation","op","from","valueToCopy","test","_get","arrOps","arr","splice","pointer","getOriginalDestination","validateOperation","mutateDocument","validator","returnValue","split","t","existingPathFragment","validateFunction","join","indexOf","applyPatch","patch","results","length_1","pathLen","existingPathLen","error","validate","sequence","externalValidator","get_fn_name","fn","exec","wrap","times","n","apply","map","Number","applyUpdateOperations","model","modelUpdateOperations","assertContract","isArrayUpdateOperations","always","contractFn","contractArgs","errorMessage","boolOrError","isBoolean","isUpdateOperation","some","isEmptyArray","isArrayOf","predicate","every","is_history_transition","transition","to","startsWith","is_entry_transition","event","is_from_control_state","controlState","is_to_history_control_state_of","is_history_control_state_of","state","substring","format_transition_label","_event","action","format_history_transition_state_name","get_all_transitions","guards","displayName","build_event_enum","array_identifiers","reduce","arguments","acc","identifier","build_nested_state_structure","states","event_emitter_factory","root_name","last_seen_state_event_emitter","hash_states","last_seen_state_listener_disposables","is_group_state","add_last_seen_state_listener","child_name","parent_name","subscribe","event_emitter_name","last_seen_state_name","console","log","history","last_seen_state","build_state_reducer","curr_constructor","forEach","state_name","state_config","curr_constructor_new","active","eval","State","nok","emitLastSeenStateEvent","onNext","current_state_name","build_state_enum","states_enum","state_name_history_fn","NOK","create_state_machine","fsmDef","settings","control_states","events","transitions","initial_extended_state","subject_factory","_control_states","_events","hash_states_struct","is_init_state","is_auto_state","send_event","event_struct","event_name","event_data","current_state","event_handler","info","[object Object]","process_event","arr_predicate","from_proto","guard","condition_checking_fn","condition_suffix","model_","actionResult","state_from","state_from_name","leave_state","update_model","next_state","model_prime","state_to","state_to_name","target_state","enter_next_state","stop","condition_checked","yield","start","makeStreamingStateMachine","fsm","merge","of","eventLabel","eventData","filter","PATH_ROOT","clone","objA","objB","assign","updatePathInTraversalState","traversalState","subTree","subTreeChildren","subTreeChild","traversalStateParent","get","traversalStateChild","currentChildPath","set","isAdded","isVisited","concat","updateVisitInTraversalState","visitTree","traversalSpecs","store","lenses","traverse","empty","emptyOrEmptyConstructor","takeAndRemoveOne","isEmpty","getChildren","visit","seed","seedOrSeedConstructor","Map","currentStore","visitAcc","clear","postOrderTraverseTree","isLeaf","shift","subTrees","unshift","result","objectTreeLenses","getLabel","values","prop","constructTree","label","children","labelKey","arrayTreeLenses","generateStatePlantUmlHeader","optDisplayName","toPlantUml","translationMap","pathMap","treeLabel","translation","stateToPlantUML","getChildrenNumber","mappedTree","childrenTranslation","format_history_states","format_entry_transitions","translate_transitions","historyStatesObj","accTranslation","historyState","format_history_transitions","format_standard_transitions","Boolean","toDagreVisualizerFormat","translatedStates","translatedTransitions"],"mappings":"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"}